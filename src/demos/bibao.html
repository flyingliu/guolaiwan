<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <script type="text/javascript">
        //面试经典问题:

        function onMyLoad(){
            /*
            抛出问题:
                此题的目的是想每次点击对应目标时弹出对应的数字下标 0~4,但实际是无论点击哪个目标都会弹出数字5
            问题所在:
                arr 中的每一项的 onclick 均为一个函数实例(Function 对象),这个函数实例也产生了一个闭包域,
                这个闭包域引用了外部闭包域的变量,其 function scope 的 closure 对象有个名为 i 的引用,
                外部闭包域的私有变量内容发生变化,内部闭包域得到的值自然会发生改变
            */
            var arr = document.getElementsByTagName("p");
            // 每次弹出的都是5

            // for(var i = 0; i < arr.length;i++){
            //     arr[i].onclick = function(){
            //         alert(i);
            //     }
            // }

            // 方法一
            // for(var i = 0; i < arr.length;i++){
            // 	(function(arg){
            // 		arr[i].onclick = function(){
            // 			console.log(arg);
            // 		}
            // 	})(i)
            // }

            // 方法二
			// for(var i = 0;i<arr.length;i++){
			//     //为当前数组项即当前 p 对象添加一个名为 i 的属性,值为循环体的 i 变量的值,
			//     //此时当前 p 对象的 i 属性并不是对循环体的 i 变量的引用,而是一个独立p 对象的属性,属性值在声明的时候就确定了
			//     //(基本类型的值都是存在栈中的,当有一个基本类型变量声明其等于另一个基本变量时,此时并不是两个基本类型变量都指向一个值,而是各自有各自的值,但值是相等的)
			//     arr[i].i = i;
			//     arr[i].onclick = function () {
			//         alert(this.i);
			//     }
			// }
			// 方法三
			/*
			解决思路:
			    与解决办法一有点相似但却有点不太相似.
			    相似点:同样是增加若干个对应的闭包域空间用来存储下标
			    不同点:解决办法一是在新增的匿名闭包空间内完成事件的绑定,而此例是将事件绑定在新增的匿名函数返回的函数上

			    此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg
			 */
			// for(var i = 0; i<arr.length;i++){
			//     arr[i].onclick = (function(arg){
			//         return function () {
			//             alert(arg);
			//         }
			//     })(i);
			// }
			// 方法四

			/*
			解决思路与解决办法一相同
			 */
			// for(var i = 0; i<arr.length;i++){
			//     (function(){
			//        var temp = i;
			//         arr[i].onclick = function () {
			//             alert(temp);
			//         }
			//     })();
			// }
			// 方法五
			/*
			解决思路与解决办法三及四相同
			 */
			// for(var i = 0;i<arr.length;i++){
			//     arr[i].onclick = (function () {
			//         var temp = i;
			//         return function () {
			//             alert(temp);
			//         }
			//     })();
			// }
			// 方法六
			/*
			解决思路:
			    将下标添加为绑定函数的属性
			 */
			// for(var i = 0;i<arr.length;i++){
			//     (arr[i].onclick = function () {
			//         alert(arguments.callee.i);      //arguments 参数对象  arguments.callee 参数对象所属函数
			//     }).i = i;
			// }
			// 方法七
			/*
			解决思路:
			    通过 new 使用 Function 的构造函数 创建 Function 实例实现,由于传入的函数体的内容是字符串,故 Function 得到的是一个字符串拷贝,而没有得到 i 的引用(这里是先获取 i.toString()然后与前后字符串拼接成一个新的字符串,Function 对其进行反向解析成 JS 代码)
			 */
			// for(var i = 0;i<arr.length;i++){
			//     arr[i].onclick = new Function("alert("+i+");");//每 new 一个 Function 得到一个 Function 对象(一个函数),有自己的闭包域
			// }
			// 方法八
			/*
			解决思路:
			    直接通过 Function 返回一个函数
			    与解决办法七的不同之处在于:
			        解决办法七使用 new,使用了 new,此时 Function 函数就被当成构造器可以用来构造一个 Function 实例返回
			        当前解决办法没有使用 new ,即将 Function 函数当成一个函数,传入参数返回一个新函数;
			        其实此处 new 与不 new 只是的区别在于:
			            使用了 new 即 Function 函数充当构造器,由 JS 解析器生产一个新的对象,构造器内的 this 指向该新对象;
			            不实用 new 即 Function 函数依旧是函数,由函数内部自己生产一个实例返回.
			 */
			for(var i = 0;i<arr.length;i++){
			    arr[i].onclick = Function("alert("+i+");");
			}
		}
    </script>
</head>
<body onload="onMyLoad()">
    <p>产品一</p>
    <p>产品二</p>
    <p>产品三</p>
    <p>产品四</p>
    <p>产品五</p>
</body>
</html>